<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Snake</title>
    <style>
        body{
            font-family: Helvetica;
        }

        canvas{
            display: block;
            position: absolute;
            border: 1px solid #000;
            margin: auto;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
        ul{
            display: flex;
            flex-direction: column-reverse;
        }
    </style>
</head>
<body>
    <canvas id="canvas">
        Sorry, your browser does not support this fabulous game.
    </canvas>

    <script>
        // Constants
        var COLS=5, ROWS=5;
        // IDs
        var EMPTY=0, FRUIT=1, SNAKE=2;
        // Directions
        var LEFT=0, UP=1, RIGHT=2, DOWN=3;
        // KeyCodes
        var KEY_SPACE=32;
        // alive
        var alive=true, win=false;

        // Game objects
        var canvas, ctx, keystate, frames, scoreA, score, pointSfx, winBg;

        var fruitPos;


        var grid = {

            width: null,
            height: null,
            _grid: null,

            init: function(d, c, r) {   // d for default value
                this.width = c;
                this.height = r;

                this._grid = [];
                for (var x = 0; x < c; x ++) {
                    this._grid.push([]);
                    for (var y = 0; y < r; y ++) {
                        this._grid[x].push(d);
                    }
                }
            },

            set: function(val, x, y) {
                this._grid[x][y] = val;
            },

            get: function(x, y) {
                return this._grid[x][y];
            }
        }

        var snake = {
            direction: null,
            head: null,
            _queue: null,

            init: function(d, x, y) {
                this.direction = d;
                this._queue = [];
                this.insert(x, y);
            },

            insert: function(x, y) {

                this._queue.unshift({x:x, y:y});
                this.head = this._queue[0];

            },

            getSize: function() {
                return this._queue.length;
            },

            equalsHead: function(x, y) {
                return this.head.x === x && this.head.y === y;
            },

            remove: function() {
                return this._queue.pop();
            }
        }

        function setFood() {
            var empty = [];
            for (var x = 0; x < grid.width; x ++) {
                for (var y = 0; y < grid.height; y ++) {
                    if (grid.get(x, y) === EMPTY) {
                        empty.push({x:x, y:y});
                    }
                }
            }
            if (empty.length === 0) {
                win = true;
                alive = false;
                return;
            }
            var randpos = empty[Math.floor(Math.random()*empty.length)];
            fruitPos = randpos;
            grid.set(FRUIT, randpos.x, randpos.y);
        }

        function main() {
            canvas = document.getElementById('canvas');
            canvas.width = COLS*20;
            canvas.height = ROWS*20;
            ctx = canvas.getContext("2d");

            ctx.font = "15px Helvetica";
            pointSfx = new Audio("sounds/sfx_point.mp3");
            winBg = new Audio("sounds/win.mp3");
            winBg.loop = true;

            frames = 0;
            keystate = {};
            document.addEventListener("keydown", function(evt) {
                keystate[evt.keyCode] = true;
            })
            document.addEventListener("keyup", function(evt) {
                delete keystate[evt.keyCode];
            })

            init();
            loop();
        }

        function init() {
            grid.init(EMPTY, COLS, ROWS);
            score = 0;
            alive = true;
            win = false;

            winBg.load();

            var spB = {x:COLS-1, y:Math.floor(ROWS/2)};
            snake.init(LEFT, spB.x, spB.y);
            snake.insert(spB.x-1, spB.y);
            grid.set(SNAKE, spB.x, spB.y);
            grid.set(SNAKE, spB.x-1, spB.y);

            for (var i = 0; i < 1; i ++) {
                setFood();
            }
        }

        function loop() {

            frames ++;

            if (frames%2 === 0) {

                if (alive) {

                    if (!bfs()) {
                        console.log('Change strategy');
                        turn();
                    }

                }

                update();

            }
            draw();

            window.requestAnimationFrame(loop, canvas);
        }

        // Simple strategy
        function turn() {
            var cx = snake.head.x;
            var cy = snake.head.y;
            var newPos = [
                {x:(cx-1<0 ? grid.width-1 : cx-1), y:cy},
                {x:(cx+1>grid.width-1 ? 0 : cx+1), y:cy},
                {x:cx, y:(cy-1<0 ? grid.height-1 : cy-1)},
                {x:cx, y:(cy+1>grid.height-1 ? 0 : cy+1)}
            ];
            var newDirection = [LEFT, RIGHT, UP, DOWN];
            for (var i = 3; i >= 0; i --) {
                if (grid.get(newPos[i].x, newPos[i].y) === SNAKE) {
                    newDirection.splice(i, 1);
                    newPos.splice(i, 1);
                }
            }
            var best = {dir:null, dist:Number.MAX_VALUE};
            for (var i = 0; i < newPos.length; i ++) {
                // manhattan distance
                var dis = Math.abs(newPos[i].x - fruitPos.x)
                        + Math.abs(newPos[i].y - fruitPos.y);
                if (dis < best.dist) {
                    best = {dir:newDirection[i], dist:dis};
                }
            }
            snake.direction = best.dir;
        }

        //BFS
        function bfs() {
            var set = new Set()
            var q = [];
            var p = [];
            set.add(JSON.stringify(snake.head));
            q.unshift(JSON.stringify(snake.head));

            while (q.length > 0) {

                var c = JSON.parse(q.pop());
                if (c.x === fruitPos.x && c.y === fruitPos.y) {
                    break;
                }
                var newPos = [
                    {x:(c.x-1<0 ? grid.width-1 : c.x-1), y:c.y},
                    {x:(c.x+1>grid.width-1 ? 0 : c.x+1), y:c.y},
                    {x:c.x, y:(c.y-1<0 ? grid.height-1 : c.y-1)},
                    {x:c.x, y:(c.y+1>grid.height-1 ? 0 : c.y+1)}
                ];
                newPos.forEach(function(neighbor) {
                    if (grid.get(neighbor.x, neighbor.y) != SNAKE
                            && !set.has(JSON.stringify(neighbor))) {
                        neighbor = JSON.stringify(neighbor);
                        set.add(neighbor);
                        p[neighbor] = c;
                        q.unshift(neighbor);
                    }
                });
            }

            var nextStep = JSON.stringify(fruitPos);
            var c = p[nextStep];

            // no solution
            if (c == undefined) {
                console.log('NO BFS SOLUTION FOUND');
                return false;
            }

            while (c.x != snake.head.x || c.y != snake.head.y) {
                nextStep = JSON.stringify(c);
                c = p[nextStep];
            }
            var newPos =[
                JSON.stringify({x:(c.x-1<0 ? grid.width-1 : c.x-1), y:c.y}),
                JSON.stringify({x:(c.x+1>grid.width-1 ? 0 : c.x+1), y:c.y}),
                JSON.stringify({x:c.x, y:(c.y-1<0 ? grid.height-1 : c.y-1)}),
                JSON.stringify({x:c.x, y:(c.y+1>grid.height-1 ? 0 : c.y+1)})
            ];

            if (nextStep === newPos[0]) {
                snake.direction = LEFT;
            } else if (nextStep === newPos[1]) {
                snake.direction = RIGHT;
            } else if (nextStep === newPos[2]) {
                snake.direction = UP;
            } else if (nextStep === newPos[3]) {
                snake.direction = DOWN;
            } else {
                console.log('??????');
            }
            return true;
        }

        function update() {

            if (keystate[KEY_SPACE])
                return init();

            var bx = snake.head.x;
            var by = snake.head.y;

            switch (snake.direction) {
                case LEFT:
                    bx --;
                    break;
                case UP:
                    by --;
                    break;
                case RIGHT:
                    bx ++;
                    break;
                case DOWN:
                    by ++;
                    break;
            }

            if (bx < 0) {
                bx = grid.width - 1;
            } else if (bx > grid.width - 1) {
                bx = 0;
            }

            if (by < 0) {
                by = grid.height - 1;
            } else if (by > grid.height - 1) {
                by = 0;
            }

            if (grid.get(bx, by) === SNAKE) {
                alive = false;
            }

            if (alive) {
                if (grid.get(bx, by) === FRUIT) {
                    pointSfx.load();
                    pointSfx.play();
                    score ++;
                    setFood();
                } else {
                    var tail = snake.remove();
                    grid.set(EMPTY, tail.x, tail.y);
                }

                grid.set(SNAKE, bx, by);
                snake.insert(bx, by);
            }
        }

        function draw() {
            // tile width and height
            var tw = canvas.width / grid.width;
            var th = canvas.height / grid.height;

            for (var x = 0; x < grid.width; x ++) {
                for (var y = 0; y < grid.height; y ++) {
                    switch (grid.get(x, y)) {
                        case EMPTY:
                            ctx.fillStyle = "#fff";
                            break;
                        case SNAKE:
                            ctx.fillStyle =
                                snake.equalsHead(x, y) ? "#cc0099" : "#9933ff";
                            break;
                        case FRUIT:
                            ctx.fillStyle = "#ff6666";
                            break;
                    }
                    ctx.fillRect(x*tw, y*th, tw, th);
                }
            }
            ctx.fillStyle = "#99c1cc";
            ctx.fillText("Score: " + score, canvas.width-70, canvas.height-10);

            if (!alive && !win) {
                // winBg.play();
                ctx.fillStyle = "#ff6666";
                ctx.fillText("Nobody wins! You all suck!",
                                    canvas.width/2-80, canvas.height/2);
            }

            if (win) {
                ctx.fillStyle = "#ff6666";
                ctx.fillText("CONGRATULATIONS!",
                                    canvas.width/2-80, canvas.height/2);
            }

        }

        main();
    </script>
</body>
</html>
